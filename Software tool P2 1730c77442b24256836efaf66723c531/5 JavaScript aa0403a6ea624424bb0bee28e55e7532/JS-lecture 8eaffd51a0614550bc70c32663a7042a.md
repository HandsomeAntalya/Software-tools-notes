# JS-lecture

![截屏2023-04-22 21.40.51.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.40.51.png)

![截屏2023-04-22 21.41.03.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.41.03.png)

![截屏2023-04-22 21.42.09.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.42.09.png)

![截屏2023-04-22 21.43.03.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.43.03.png)

![截屏2023-04-22 21.43.25.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.43.25.png)

In JavaScript, the term "**execution context**" refers to the environment in which a piece of code is currently running (excuting). An execution context determines the scope of variables, the value of the **`this`** keyword, and how the code behaves. Whenever a piece of JavaScript code is executed, it runs within a specific execution context. 在 JavaScript 中，“**执行上下文**”一词是指代码当前运行的环境。执行上下文确定变量的范围、**`this`** 关键字的值以及代码的行为方式。每当执行一段 JavaScript 代码时，它都在特定的执行上下文中运行。

There are three types of execution contexts in JavaScript, JavaScript有三种执行上下文：

1. **Global Execution Context 全局执行上下文**： This is the default context in which JavaScript code runs when it is not inside a function. In a web browser, the global execution context is associated with the **`window`** object, and any variables or functions declared at the global level become properties of the **`window`** object. 当JavaScript代码不在函数内部运行时，这是默认的上下文。在Web浏览器中，全局执行上下文与**`window`**对象相关联，任何在全局级别声明的变量或函数都变成了**`window`*对象的属性。
2. **Local (Function) Execution Context** 本地（函数）执行上下文: A local execution context is created when a function is called. Each function call creates a new local execution context, separate from the global context. This means that any variable declared within a function is local to that function and cannot be accessed outside of it. When the function finishes execution, its local execution context is destroyed, and the control returns to the calling context (usually the global context or another local context if the function is called within another function).  当一个函数被调用时，一个本地执行上下文被创建。每个函数调用都会创建一个新的本地执行环境，与全局环境分开。这意味着在一个函数中声明的任何变量都是该函数的本地变量，不能在该函数之外被访问。当函数执行完毕时，其局部执行上下文被销毁，控制权返回到调用上下文（通常是全局上下文或另一个局部上下文，如果该函数是在另一个函数中调用的）。
3. **Eval Execution ContextEval 执行上下文**: This is a special context created when executing code within an **`eval()`** function. However, using **`eval()`** is generally discouraged due to security concerns and performance issues. 在使用**`eval()`**函数执行代码时创建的特殊上下文。但由于安全问题和性能问题，通常不建议使用**`eval()`*。

Here's an example to demonstrate execution contexts:

```jsx
// Global Execution Context
var globalVar = "I'm a global variable";

function exampleFunction() {
  // Local Execution Context
  var localVar = "I'm a local variable";
  console.log(globalVar); // Accessible here: "I'm a global variable"
  console.log(localVar);  // Accessible here: "I'm a local variable"
}

exampleFunction();

console.log(globalVar); // Accessible here: "I'm a global variable"
console.log(localVar);  // Error: localVar is not defined

```

In this example, **`globalVar`** is declared in the global execution context, and **`localVar`** is declared within the **`exampleFunction`**'s local execution context. While **`globalVar`** can be accessed both inside and outside the function, **`localVar`** can only be accessed within the function's local execution context.

When a JavaScript program runs, it goes through the following steps to manage execution contexts:

1. **Creation创建**： Before executing the code, JavaScript creates an execution context and sets up memory space for variables and functions. In this phase, functions are fully defined, but variables are initialized with a value of **`undefined`**.在执行代码之前，JavaScript 创建一个执行上下文并为变量和函数设置内存空间。在此阶段，函数被完全定义，但变量的初始值为 **`undefined`**。
2. **Activation/Code Execution 激活/代码执行**：JavaScript executes the code line by line within the context. Variables are assigned their actual values, and function calls create new function execution contexts.JavaScript在上下文中逐行执行代码。变量被赋予它们的实际值，函数调用会创建新的函数执行上下文。
3. **Deletion** 删除: Once the code execution is completed, the execution context is removed from memory. However, if there are any closures (inner functions referencing variables from an outer function), the context may be preserved for those closures.  一旦代码执行完成，执行上下文将从内存中删除。然而，如果有任何闭合（内层函数引用外层函数的变量），上下文可以为这些闭合保留下来。

JavaScript uses a data structure called the "call stack" to manage execution contexts. The call stack is a Last-In, First-Out (LIFO) structure, meaning the most recently added context is the first one to be removed. When the program starts, the global execution context is pushed onto the call stack. Whenever a function is called, a new function execution context is created and pushed onto the call stack. When a function finishes executing, its context is popped off the call stack, and control returns to the calling context. 使用一个名为 "调用栈 "的数据结构来管理执行上下文。调用堆栈是一个后进先出（LIFO）结构，意味着最近添加的上下文是第一个被删除的。当程序启动时，全局执行上下文被推送到调用栈中。每当一个函数被调用时，就会创建一个新的函数执行上下文并推送到调用栈上。当一个函数执行完毕时，它的上下文被从调用栈中弹出，控制权返回到调用上下文。

Understanding execution contexts is essential for grasping how JavaScript handles variable scoping, closures, and the behavior of the **`this`** keyword. 理解执行环境对于掌握JavaScript如何处理变量范围、闭包和this关键字的行为至关重要。

![截屏2023-04-22 21.43.59.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.43.59.png)

![截屏2023-04-22 21.44.54.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.44.54.png)

undefined and not defined 

In JavaScript, **`undefined`** and "not defined" refer to two different concepts:

1. **undefined**: A variable is **`undefined`** when it has been declared but has not been assigned a value. In other words, the variable exists, but its value is **`undefined`**. JavaScript automatically initializes variables with the **`undefined`** value when they are declared.

```jsx
let exampleVar;
console.log(exampleVar); // Output: undefined
```

In this example, **`exampleVar`** has been declared but not assigned a value, so its value is **`undefined`**.

1. **Not defined**: When a variable has not been declared at all, it is "not defined." Trying to access a variable that has not been declared results in a **`ReferenceError`**.

```jsx
console.log(nonExistentVar); // Output: ReferenceError: nonExistentVar is not defined
```

In this example, **`nonExistentVar`** has not been declared, so attempting to access it results in a **`ReferenceError`**.

In summary, **`undefined`** is the default value assigned to a declared variable that has not been assigned a value, while "not defined" refers to a variable that has not been declared at all, which leads to a **`ReferenceError`** when attempting to access it.

![截屏2023-04-22 21.46.00.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.46.00.png)

![截屏2023-04-22 21.46.49.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.46.49.png)

Hoisting is a JavaScript mechanism in which variable and function declarations are moved to the top of their containing scope during the compilation phase, before the code is executed. It's important to note that only the declarations are hoisted, not the initializations or assignments. This means that you can use a variable or function before it has been declared in the code, without encountering an error. 提升是 JavaScript 机制之一，在编译阶段变量和函数声明会被移动到它们所在的作用域顶部，在代码执行前。需要注意的是，只有声明会被提升，而不是初始化或赋值。这意味着你可以在代码中使用一个变量或函数，即使它还没有被声明，而不会遇到错误。

Hoisting occurs differently for variables and functions:

1. **Variable hoisting**: When a variable is declared using **`var`**, its declaration is hoisted to the top of the current scope (either the function scope or the global scope). However, the assignment of a value to the variable is not hoisted. If you try to access the variable before its assignment, you'll get the value **`undefined`**. 变量提升：当使用 **`var`** 声明变量时，其声明会被提升到当前作用域的顶部（函数作用域或全局作用域）。但是，给变量赋值的操作不会被提升。如果在赋值之前尝试访问变量，将得到值 **`undefined`**。

```jsx
console.log(exampleVar); // Output: undefined
var exampleVar = 5;
console.log(exampleVar); // Output: 5
```

In this example, the variable declaration **`var exampleVar`** is hoisted, but the assignment **`exampleVar = 5`** is not. That's why the first **`console.log()`** outputs **`undefined`**.

1. **Function hoisting**: Function declarations are hoisted to the top of their containing scope, along with their implementation. This allows you to call a function before it's declared in the code. **函数提升**：函数声明会被提升到包含它们的作用域顶部，连同它们的实现一起。这使得你可以在代码中在函数被声明之前调用它。

```jsx
console.log(exampleFunc()); // Output: "Function called"
function exampleFunc() {
  return "Function called";
}
```

In this example, the entire function declaration, including its implementation, is hoisted, which is why you can call **`exampleFunc()`** before it appears in the code.

It's important to note that hoisting does not apply to variables declared with **`let`** and **`const`**. If you try to access a **`let`** or **`const`** variable before its declaration, you will encounter a **`ReferenceError`**.

Understanding hoisting is crucial for avoiding common pitfalls related to variable and function declarations in JavaScript. Being aware of hoisting behavior can help you write more predictable and less error-prone code.

![截屏2023-04-22 21.47.53.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.47.53.png)

![截屏2023-04-22 21.48.04.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.48.04.png)

In JavaScript, scope determines the **visibility and accessibility** of variables and functions within the code. Variable is created by its parents, but not the child. It defines where a variable or function can be used and where it cannot be accessed. There are two primary types of scope in JavaScript: global scope and local scope.

1. **Global scope**: Variables and functions declared outside any function or block have a global scope. They can be accessed from any part of the code, including within functions. In a web browser, global variables and functions become properties of the **`window`** object.

```jsx
let globalVar = "I'm a global variable.";

function exampleFunc() {
  console.log(globalVar); // Output: "I'm a global variable."
}

exampleFunc();
```

In this example, **`globalVar`** is accessible both in the global scope and within **`exampleFunc()`** because it has a global scope.

1. **Local scope**: Variables and functions declared within a function or block have a local scope. They can only be accessed within that function or block and are not visible outside of it.**局部作用域**：在函数或块内声明的变量和函数具有局部作用域。它们只能在该函数或块内部访问，而在外部不可见。

```jsx
function exampleFunc() {
  let localVar = "I'm a local variable.";
  console.log(localVar); // Output: "I'm a local variable."
}

exampleFunc();
console.log(localVar); // Output: ReferenceError: localVar is not defined
```

In this example, **`localVar`** is only accessible within **`exampleFunc()`** and is not visible in the global scope, which is why attempting to access it outside the function results in a **`ReferenceError`**.

JavaScript also has block-level scope when using **`let`** and **`const`** to declare variables within a block (e.g., within a loop or conditional statement). Variables declared with **`let`** or **`const`** are only accessible within the block they are declared in.

```jsx
if (true) {
  let blockVar = "I'm a block variable.";
  console.log(blockVar); // Output: "I'm a block variable."
}

console.log(blockVar); // Output: ReferenceError: blockVar is not defined
```

In this example, **`blockVar`** is only accessible within the **`if`** block and is not visible outside of it.

Understanding scope in JavaScript is essential for managing variable visibility and avoiding unintended side effects, such as accidentally modifying a global variable or encountering a **`ReferenceError`** due to accessing an out-of-scope variable.

![截屏2023-04-22 21.49.11.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.49.11.png)

The **call stack** is a data structure used by programming languages, including JavaScript, to keep track of function calls and their execution context. When a function is called, an entry (called a stack frame) is added to the top of the call stack, and when the function returns, its entry is removed from the top of the stack. The call stack operates in a last-in, first-out (LIFO) order, meaning the most recently added stack frame is the first one to be removed.**调用栈**是程序语言（包括JavaScript在内）用于跟踪函数调用及其执行上下文的数据结构。当调用一个函数时，会在调用栈的顶部添加一个条目（称为堆栈帧），并且当函数返回时，其条目将从堆栈的顶部删除。调用栈按照后进先出（LIFO）的顺序运作，这意味着最近添加的堆栈帧最先被删除。

Each stack frame contains information about the function call, such as the function's name, its arguments, the return address (where the program should continue executing after the function returns), and any local variables.

Here's a simple example of how the call stack works in JavaScript:

```jsx
function funcA() {
  console.log("Function A");
  funcB();
}

function funcB() {
  console.log("Function B");
  funcC();
}

function funcC() {
  console.log("Function C");
}

funcA();

```

When the code is executed, the call stack goes through the following steps:

1. Initially, the call stack is empty.
2. **`funcA()`** is called. A stack frame for **`funcA`** is added to the top of the call stack.
3. Inside **`funcA`**, **`funcB()`** is called. A stack frame for **`funcB`** is added to the top of the call stack.
4. Inside **`funcB`**, **`funcC()`** is called. A stack frame for **`funcC`** is added to the top of the call stack.
5. **`funcC()`** finishes executing and returns. Its stack frame is removed from the top of the call stack.
6. **`funcB()`** finishes executing and returns. Its stack frame is removed from the top of the call stack.
7. **`funcA()`** finishes executing and returns. Its stack frame is removed from the top of the call stack.
8. The call stack is now empty.

The call stack is essential for managing the execution flow of a program. However, it has a limited size, and if too many function calls are nested (e.g., due to deep recursion), a stack overflow error can occur when the call stack exceeds its limit.

![截屏2023-04-22 21.50.05.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.50.05.png)

![截屏2023-04-22 21.51.06.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.51.06.png)

![截屏2023-04-22 21.51.16.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.51.16.png)

JavaScript is a versatile programming language with a syntax that is easy to read and write. Here's an overview of some of the essential elements of JavaScript syntax:

1. **Variables**: Variables are used to store values. JavaScript has three ways to declare variables: **`var`**, **`let`**, and **`const`**. **`var`** is function-scoped and can be redeclared, while **`let`** and **`const`** are block-scoped and cannot be redeclared. **`const`** variables also cannot be reassigned after their initial assignment.

- **true** Variables with block scope are declared using the `let` keyword.
- **true** The keyword `const` is used to to declare variables that you should not change after they are assigned.
- **false** A variable declared outside a function definition using the `let` keyword is a global variable. It is accessible within the block it is declared in but not globally.
- **true** A variable declared outside a function definition using the `var` keyword is a global variable.

```jsx
var myVar = 10;
let myLet = 20;
const myConst = 30;

```

1. **Data types**: JavaScript has several basic data types, including numbers, strings, and booleans. Objects and arrays are also commonly used data structures.

```jsx
let num = 42;
let str = 'Hello, world!';
let bool = true;

let obj = { key: 'value' };
let arr = [1, 2, 3];

```

1. **Operators**: JavaScript provides various operators for performing operations on values, such as arithmetic, comparison, and logical operations.

```jsx
let sum = 10 + 20;
let isEqual = 5 == '5'; // loose equality
let isStrictEqual = 5 === '5'; // strict equality
let notEqual = 5 !== '5'; // strict inequality
let and = true && false;
let or = true || false;

```

1. **Control structures**: JavaScript supports common control structures, such as **`if`** statements, **`for`** loops, and **`while`** loops.

```jsx
if (x > 10) {
  console.log('x is greater than 10');
} else {
  console.log('x is not greater than 10');
}

for (let i = 0; i < 5; i++) {
  console.log(i);
}

while (x < 10) {
  console.log('x is less than 10');
  x++;
}

```

1. **Functions**: Functions are reusable blocks of code that can be defined and called by name. Functions can have parameters and return values.

```jsx
function greet(name) {
  return 'Hello, ' + name + '!';
}

let greeting = greet('Alice');
console.log(greeting); // Output: 'Hello, Alice!'

```

1. **Objects**: JavaScript is an object-oriented language, and you can create and manipulate objects using dot notation or bracket notation.

```jsx
let person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
};

console.log(person.firstName); // Output: 'John'
console.log(person['lastName']); // Output: 'Doe'

```

These are just a few examples of the basic elements of JavaScript syntax. As you dive deeper into the language, you'll encounter more advanced concepts and constructs, such as classes, asynchronous programming, and various built-in objects and functions.

![截屏2023-04-22 21.51.46.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.51.46.png)

![截屏2023-04-22 21.52.44.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.52.44.png)

![截屏2023-04-22 21.53.41.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.53.41.png)

In JavaScript, arrays are used to store multiple values in a single variable. Arrays are ordered, indexed, and zero-based. Here's an example of an array in JavaScript:

```jsx
let fruits = ['apple', 'banana', 'cherry'];
```

You can access elements of an array using their index:

```jsx
console.log(fruits[0]); // Output: 'apple'
console.log(fruits[1]); // Output: 'banana'
```

You can also modify the contents of an array:

```jsx
fruits[2] = 'grape';
console.log(fruits); // Output: ['apple', 'banana', 'grape']
```

Arrays in JavaScript have a property called **`length`** that gives you the number of elements in the array:

```jsx
console.log(fruits.length); // Output: 3
```

**For loop**

A **`for`** loop is a common control structure used to iterate over a sequence of values, like an array. Here's an example of using a **`for`** loop with an array:

```
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}
```

This loop will iterate through the **`fruits`** array and print each element to the console.

**For...in loop**

The **`for...in`** loop is used to iterate over the enumerable properties of an object. It's not recommended to use it with arrays, as the order of iteration is not guaranteed, and it may also iterate over non-integer properties.

```jsx
for (let index in fruits) {
  console.log(fruits[index]);
}
```

**For...of loop**

The **`for...of`** loop is a more modern way to iterate over iterable objects, like arrays, strings, and some other data structures. The **`for...of`** loop automatically iterates over the values of the iterable, without the need for an index:

```jsx
for (let fruit of fruits) {
  console.log(fruit);
}
```

This loop will iterate through the **`fruits`** array and print each element to the console, just like the regular **`for`** loop, but with a simpler and more concise syntax.

![截屏2023-04-22 21.54.19.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.54.19.png)

An **anonymous functio**n is a function that is defined without a name. Anonymous functions can be used as arguments for other functions or assigned to variables. They are sometimes referred to as "function literals" or "lambda functions." **匿名函数**是指没有名称定义的函数。匿名函数可作为其他函数的参数或分配给变量。它们有时被称为“函数文字”或“lambda函数”。

In JavaScript, anonymous functions are often used as **callback functions**, which are passed as arguments to other functions and executed later, usually as part of an event, like a user action or an asynchronous operation.

Here's an example of an anonymous function used as a callback for the **`setTimeout`** function:

```jsx
setTimeout(function() {
  console.log('This message will be displayed after 2 seconds.');
}, 2000);

```

In this example, the anonymous function is passed as the first argument to **`setTimeout`**, and it will be executed after a delay of 2000 milliseconds (2 seconds).

You can also assign an anonymous function to a variable, like this:

```jsx
let greet = function(name) {
  console.log('Hello, ' + name);
};

greet('Alice'); // Output: 'Hello, Alice'
```

In this example, the anonymous function is assigned to the variable **`greet`**, which can then be used like a named function.

With the introduction of arrow functions in ECMAScript 2015 (ES6), you can create anonymous functions with a more concise syntax:

```jsx
setTimeout(() => {
  console.log('This message will be displayed after 2 seconds.');
}, 2000);

let greet = (name) => {
  console.log('Hello, ' + name);
};

greet('Alice'); // Output: 'Hello, Alice'
```

Arrow functions provide a shorter syntax for creating anonymous functions and have some differences in behavior compared to regular anonymous functions, such as how they handle the **`this`** keyword.

![截屏2023-04-22 21.54.38.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.54.38.png)

Arrow functions are a more concise way to create anonymous functions in JavaScript, introduced in ECMAScript 2015 (ES6). They use a special syntax with a "fat arrow" (**`=>`**) to define the function. Arrow functions have some key differences compared to regular functions:

箭头函数是JavaScript中创建匿名函数的更简洁方式，引入于ECMAScript 2015（ES6）。它们使用“胖箭头”（** `=>` **）的特殊语法来定义函数。与常规函数相比，箭头函数有一些关键区别：

1. **Concise syntax**: Arrow functions have a shorter and more compact syntax compared to regular functions.

```jsx
// Regular function
function sum(a, b) {
  return a + b;
}

// Arrow function
const sum = (a, b) => a + b;
```

1. **No `this` binding**: Arrow functions do not have their own **`this`** value. Instead, they inherit the **`this`** value from the enclosing scope. This can be useful when working with callbacks and event handlers, where you often want to access the outer context inside the function.

```jsx
function MyObject() {
  this.value = 10;

  setTimeout(function() {
    console.log(this.value); // undefined, because `this` refers to the global object or is undefined in strict mode
  }, 1000);

  setTimeout(() => {
    console.log(this.value); // 10, because `this` is inherited from the enclosing scope (the constructor function)
  }, 1000);
}
```

1. **No `arguments` object**: Arrow functions do not have their own **`arguments`** object, and they inherit it from the enclosing scope, just like **`this`**.

```jsx
function outer() {
  const inner = () => {
    console.log(arguments[0]); // Output: 'hello', because `arguments` is inherited from the `outer` function
  };

  inner();
}

outer('hello');
```

1. **Always anonymous**: Arrow functions are always anonymous, meaning they cannot have a name. They can, however, be assigned to variables.

```jsx
const greet = (name) => `Hello, ${name}`;
console.log(greet('Alice')); // Output: 'Hello, Alice'
```

1. **No `prototype` property**: Arrow functions do not have a **`prototype`** property, so they cannot be used as constructors for creating new objects with the **`new`** keyword.

```jsx
const MyObject = () => {};
const obj = new MyObject(); // TypeError: MyObject is not a constructor
```

These features make arrow functions a popular choice for callbacks, event handlers, and other situations where a concise syntax and the inherited **`this`** value are beneficial. However, arrow functions should not be used in every situation, as they have limitations, such as not being suitable for object constructors or methods that need to access their own **`this`** value.

![截屏2023-04-22 21.55.10.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_21.55.10.png)

In JavaScript, an event is an action or occurrence that happens in the browser, usually as a result of user interaction or system activity. Events can be used to detect and respond to these actions, allowing you to create dynamic and interactive web applications. Some common examples of events include:

- **`click`**: Triggered when a user clicks on an element, like a button or a link.
- **`mousemove`**: Triggered when the mouse cursor moves over an element.
- **`keydown`**: Triggered when a user presses a key on the keyboard.
- **`submit`**: Triggered when a form is submitted.
- **`load`**: Triggered when a resource, like an image or an external script, has finished loading.
- **`resize`**: Triggered when the browser window is resized.

To handle events in JavaScript, you can use event listeners. An event listener is a function that is called when a specific event occurs on a specific element. You can add event listeners using the **`addEventListener`** method on an element:

```
javascriptCopy code
const button = document.querySelector('#myButton');

button.addEventListener('click', function() {
  console.log('Button clicked!');
});

```

In this example, an event listener is added to a button element. When the button is clicked, the anonymous function will be called, and "Button clicked!" will be logged to the console.

Event listeners can also be removed using the **`removeEventListener`** method. To remove an event listener, you must pass the same function reference that was used when adding the listener:

```
javascriptCopy code
function handleClick() {
  console.log('Button clicked!');
}

button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);

```

In this example, the **`handleClick`** function is added as an event listener and then immediately removed. Since the same function reference is used for both adding and removing the listener, the event listener will be effectively removed.

Events in JavaScript also have an event object associated with them, which provides additional information about the event, such as the target element, the type of event, and any data specific to that event. The event object is automatically passed as the first argument to the event listener function:

```jsx
button.addEventListener('click', function(event) {
  console.log('Event type:', event.type); // Output: 'Event type: click'
  console.log('Target element:', event.target); // Output: 'Target element: [object HTMLButtonElement]'
});
```

In this example, the event object is used to access the event type and target element inside the event listener function.

![截屏2023-04-22 22.11.45.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.11.45.png)

# JSON

![截屏2023-04-22 22.13.11.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.13.11.png)

**JSON (JavaScript Object Notation)** is a lightweight data interchange format that i**s easy for humans to read and write** and **easy for machines to parse and generate**. JSON is a text format that is completely language-independent but uses conventions that are familiar to programmers of the C family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.

JSON is often used to **transmit data** between a server and a web application or between different parts of an application. It is a popular alternative to XML because it is less verbose and easier to work with in many programming languages.

**A JSON object** is a collection of **key-value pairs**, where the keys are strings and the values can be strings, numbers, booleans, objects, or arrays. Here's an example of a JSON object:

```json
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "courses": ["math", "history", "chemistry"]
}
```

In this example, the JSON object represents a person with a name, age, a boolean flag indicating if they are a student, and an array of courses they are taking.

In JavaScript, you can work with JSON data using the **`JSON.parse()`** function to convert a JSON string into a JavaScript object and the **`JSON.stringify()`** function to convert a JavaScript object into a JSON string:

```jsx
// JSON string
const jsonString = '{"name": "Alice", "age": 30, "isStudent": false, "courses": ["math", "history", "chemistry"]}';

// Convert JSON string to JavaScript object
const jsonObject = JSON.parse(jsonString);

console.log(jsonObject.name); // Output: "Alice"

// Convert JavaScript object to JSON string
const newJsonString = JSON.stringify(jsonObject);

console.log(newJsonString); // Output: '{"name":"Alice","age":30,"isStudent":false,"courses":["math","history","chemistry"]}'
```

In this example, a JSON string is parsed into a JavaScript object, which is then modified and converted back into a JSON string.

![截屏2023-04-22 22.13.56.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.13.56.png)

Basic about JSON

![截屏2023-04-22 22.15.05.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.15.05.png)

![截屏2023-04-22 22.16.31.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.16.31.png)

![截屏2023-04-22 22.16.16.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.16.16.png)

![截屏2023-04-22 22.16.52.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.16.52.png)

**xml can’t use arrays**

**JSON can use arrays** 

JSON (JavaScript Object Notation) and XML (eXtensible Markup Language) are both formats for storing and exchanging data. While they have some similarities, they also have several differences that can make one more suitable than the other, depending on the specific use case.

1. **Readability:**
    - JSON: JSON is easier for humans to read and write due to its compact syntax and clear structure.
    - XML: XML is more verbose **冗长的** , with opening and closing tags for each element, which can make it harder to read and write.
2. **Syntax:**
    - JSON: JSON uses **key-value pairs 键值对** to represent data, similar to JavaScript objects.
    - XML: XML uses tags, attributes, and elements to represent data, similar to HTML.
3. **Data types:**
    - JSON: JSON has built-in support for basic data types like strings, numbers, booleans, objects, and arrays.
    - XML: XML treats all data as text by default. Data types must be specified using additional schemas (such as XSD) or handled at the application level.
4. Namespaces:
    - JSON: JSON doesn't have built-in support for namespaces.
    - XML: XML supports namespaces, which allows for the mixing of different XML vocabularies without naming conflicts.
5. Metadata:
    - JSON: JSON has no built-in support for metadata, but it can be included as part of the data structure.
    - XML: XML can include metadata using attributes, comments, and processing instructions.
6. File size:
    - JSON: JSON files are generally smaller and more compact than XML files because they don't require opening and closing tags for each element.
    - XML: XML files tend to be larger due to the verbose syntax.
7. Parsing and manipulation:
    - JSON: JSON is easily parsed and manipulated in JavaScript and many other programming languages using built-in functions or libraries.
    - XML: XML parsing and manipulation often require additional libraries or tools, especially in languages other than JavaScript.
8. Compatibility:
    - JSON: JSON is natively supported by JavaScript and has become the de facto standard for web APIs and modern web applications.
    - XML: XML was the primary data format for web services before JSON gained popularity, and it's still used in many legacy systems and applications.

In summary, JSON is generally preferred for its simplicity, readability, and native support in JavaScript and other programming languages. However, XML may be a better choice for specific use cases that require more complex data structures, namespaces, or metadata.

# Object Oriented Paradigm

Object-Oriented Paradigm (OOP) is a programming paradigm that revolves around the concept of objects, which represent instances of a certain class or type. OOP is based on the idea that software should be organized into modular units, making it easier to design, develop, and maintain complex applications.

The main concepts of OOP include:

1. Classes: A class is a blueprint or template for creating objects. It defines the structure and behavior of the objects that will be created from it. Classes can have properties (data) and methods (functions) that operate on the properties.
2. Objects: An object is an instance of a class. It represents a specific entity in the program with its own set of properties and methods. Objects are created from classes and can interact with each other through their methods.
3. Encapsulation: Encapsulation is the idea of bundling data and the methods that operate on that data within a single unit (a class). This allows for better control over the data and hides the internal implementation details from the outside world.
4. Inheritance: Inheritance is a mechanism that allows one class to inherit the properties and methods of another class. This promotes code reuse and allows for the creation of more specialized classes based on existing ones. The class that is being inherited from is called the parent (or base) class, and the class that inherits is called the child (or derived) class.
5. Polymorphism: Polymorphism is the ability of a function or method to take on multiple forms, allowing objects of different classes to be treated as if they were objects of the same class. This is achieved through method overriding (in which a child class provides a new implementation for a method inherited from the parent class) or interfaces (in languages that support them).
6. Abstraction: Abstraction is the process of simplifying complex systems by breaking them down into smaller, more manageable components. In OOP, abstraction is achieved by designing classes that represent the essential features of a problem domain while hiding the unnecessary details.

Many programming languages support OOP, including Java, C++, C#, Python, and JavaScript (using prototypes or the more recent class-based syntax). Using OOP can lead to more modular, reusable, and maintainable code, making it easier to develop large-scale applications and systems.

![截屏2023-04-22 22.20.21.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.20.21.png)

![截屏2023-04-22 22.21.33.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.21.33.png)

In **object-oriented programming**, a constructor is a special method within a class that is responsible for initializing new objects of that class. When you create an object, the constructor is automatically called, and it typically sets the initial values for the object's properties and performs any required setup.

Constructors have the following characteristics:

1. They have the same name as the class they belong to.
2. They don't have a return type (not even void) because they don't return a value.
3. They can have parameters, just like any other method, which can be used to initialize the object's properties.
4. If a class does not have a constructor explicitly defined, most programming languages provide a default constructor with no parameters and an empty body.

Here's a similar example using JavaScript:

```jsx
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

// Creating an object of the Person class
const alice = new Person("Alice", 30);

console.log(alice.name);  // Output: "Alice"
console.log(alice.age);   // Output: 30
```

In this JavaScript example, the **`constructor`** method within the **`Person`** class serves the same purpose as the **`__init__`** method in the Python example.

![截屏2023-04-22 22.21.55.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.21.55.png)

![截屏2023-04-22 22.22.28.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.22.28.png)

![截屏2023-04-22 22.22.36.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.22.36.png)

![截屏2023-04-22 22.23.27.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.23.27.png)

![截屏2023-04-22 22.23.37.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.23.37.png)

JavaScript objects are lightweights. 

Objects can be created without using a class using literals.  

Objects can be created using functions with a constructor. 

![截屏2023-04-22 22.24.03.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.24.03.png)

### Literals:

Literals are notations for representing fixed values in the source code. They are used to create primitive values such as strings, numbers, booleans, or objects. Here are some examples of literals in JavaScript:

- String literals: **`"Hello, World!"`** or **`'Hello, World!'`**
- Number literals: **`42`** or **`3.14`**
- Boolean literals: **`true`** or **`false`**
- Object literals: **`{ name: 'Alice', age: 30 }`**
- Array literals: **`[1, 2, 3, 4, 5]`**
- Regular expression literals: **`/[A-Za-z0-9]+/`**

Literals are used to initialize variables or pass values to functions.

![截屏2023-04-22 22.24.23.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.24.23.png)

### Functions:

Functions are blocks of code that can be defined and called by name. They can accept input parameters, perform a specific task, and return a value. Functions are used to modularize and reuse code, making it easier to maintain and understand.

In JavaScript, functions can be defined in several ways:

- Function declaration:
    
    ```jsx
    function greet(name) {
        return 'Hello, ' + name + '!';
    }
    
    ```
    
- Function expression:
    
    ```jsx
    
    const greet = function(name) {
        return 'Hello, ' + name + '!';
    };
    ```
    
- Arrow functions:
    
    ```jsx
    const greet = (name) => 'Hello, ' + name + '!';
    ```
    

Functions can be called by their name, followed by parentheses containing any required arguments:

```jsx
console.log(greet('Alice'));  // Output: "Hello, Alice!"
```

In summary, literals are used to represent fixed values in the source code, while functions are reusable blocks of code that can be called by name and can accept input parameters and return values. Both literals and functions are essential building blocks in JavaScript programming.

![截屏2023-04-22 22.24.53.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.24.53.png)

prototype keyword. 

**Inheritance** is a mechanism in object-oriented programming that allows one class or object to inherit the properties and methods of another class or object. This promotes code reuse and allows for the creation of more specialized classes or objects based on existing ones.

JavaScript is a prototype-based language, which means that inheritance in JavaScript is achieved through prototypes rather than class-based inheritance as in some other languages like Java or C#. In JavaScript, every object has an internal reference to another object called its prototype. When a property or method is accessed on an object, JavaScript first looks for that property or method on the object itself. If it's not found, JavaScript looks for it on the object's prototype, and then on the prototype's prototype, and so on, up the prototype chain until it finds the property or method or reaches the end of the chain (which is usually the built-in Object prototype).JavaScript是一种基于原型的语言，这意味着JavaScript中的继承是通过原型而不是类继承实现的，例如在Java或C#等其他语言中。在JavaScript中，每个对象都具有对另一个对象的内部引用，称为其原型。当访问对象上的属性或方法时，JavaScript首先在对象本身上查找该属性或方法。如果未找到，则JavaScript会在对象的原型上查找它，然后在原型的原型上查找，依此类推，一直沿着原型链直到找到该属性或方法或到达链的末端（通常是内置对象原型）。

Here's a basic example of inheritance using prototypes in JavaScript:

```jsx
// Constructor function for Person
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Adding a method to the Person prototype
Person.prototype.greet = function() {
  return 'Hello, ' + this.name + '!';
};

// Constructor function for Employee, which inherits from Person
function Employee(name, age, jobTitle) {
  Person.call(this, name, age);
  this.jobTitle = jobTitle;
}

// Setting up the prototype chain for inheritance
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// Adding a method to the Employee prototype
Employee.prototype.describe = function() {
  return this.name + ' is a ' + this.jobTitle;
};

const alice = new Employee('Alice', 30, 'Software Engineer');

console.log(alice.greet());       // Output: "Hello, Alice!"
console.log(alice.describe());    // Output: "Alice is a Software Engineer"

```

In this example, we first define a **`Person`** constructor function and add a **`greet`** method to its prototype. Then, we create an **`Employee`** constructor function that inherits from **`Person`** by calling **`Person.call(this, name, age)`** and setting up the prototype chain using **`Object.create(Person.prototype)`** and **`Employee.prototype.constructor = Employee`**. Finally, we add a **`describe`** method to the **`Employee`** prototype. When we create an **`Employee`** object like **`alice`**, it can access both the **`greet`** method from the **`Person`** prototype and the **`describe`** method from its own prototype.

With the introduction of ES6 classes, the syntax for inheritance has been simplified, but the underlying prototype-based mechanism remains the same:

```jsx
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    return 'Hello, ' + this.name + '!';
  }
}

class Employee extends Person {
  constructor(name, age, jobTitle) {
    super(name, age);
    this.jobTitle = jobTitle;
  }

  describe() {
    return this.name + ' is a ' + this.jobTitle;
  }
}

const alice = new Employee('Alice', 30, 'Software Engineer');

console.log(alice.greet());       // Output: "Hello, Alice!"
console.log(alice.describe());    // Output: "Alice is a Software Engineer"

```

In this ES6 example, we use the **`class`** keyword to define **`Person`** and **`Employee`**, and the **`extends`** keyword to set up inheritance. The **`super`** keyword is used to call the parent class constructor from the child class constructor.

# Asynchronous JavaScript

**Asynchronous JavaScript** is a programming technique that allows JavaScript code to execute non-blocking operations, such as making HTTP requests or performing complex calculations, without blocking the main thread of execution. Asynchronous programming is achieved using callback functions, promises, and async/await syntax.

In traditional synchronous JavaScript, code is executed one line at a time, and each line must be executed before the next line can be executed. This can cause delays and freezes in the user interface if the code is performing a long-running operation, such as making an HTTP request.

Asynchronous JavaScript allows code to be executed in a non-blocking way. For example, when making an HTTP request, the request is sent to the server, and the code continues to execute without waiting for the response. Once the response is received, a callback function is executed to handle the response. This allows the user interface to remain responsive and prevents delays and freezes.

Here's an example of how to make an HTTP request using asynchronous JavaScript with the XMLHttpRequest object:

```jsx
const request = new XMLHttpRequest();
request.open('GET', 'https://api.example.com/data');
request.onload = function() {
  if (request.status === 200) {
    const data = JSON.parse(request.responseText);
    console.log(data);
  } else {
    console.log('Error: ' + request.statusText);
  }
};
request.send();
```

In the above example, an HTTP request is made to the URL **`https://api.example.com/data`**. The **`onload`** event is set to a callback function that will be executed once the response is received. If the status code of the response is **`200`** (OK), the response data is parsed as JSON and logged to the console. If there is an error, an error message is logged to the console.

Asynchronous programming is an important technique in modern web development, as it allows web applications to perform complex operations without blocking the user interface.

![截屏2023-04-22 22.31.03.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.31.03.png)

Call backs:

![截屏2023-04-22 22.32.03.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.32.03.png)

In JavaScript, a callback is a function that is passed as an argument to another function and is executed when that function completes its task. Callback functions are commonly used in asynchronous programming to handle the results of a long-running operation, such as making an HTTP request or processing a large file.

Here's an example of how to use a callback function in JavaScript:

```jsx
function fetchData(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function() {
    if (xhr.status === 200) {
      callback(null, xhr.responseText);
    } else {
      callback(xhr.statusText, null);
    }
  };
  xhr.send();
}

fetchData('https://api.example.com/data', function(error, data) {
  if (error) {
    console.error(error);
  } else {
    console.log(data);
  }
});
```

In the above example, the **`fetchData`** function takes two arguments: a URL and a callback function. The function makes an HTTP request to the specified URL and executes the callback function once the response is received. If there is an error, the callback function is called with the error message as the first argument and **`null`** as the second argument. If the request is successful, the callback function is called with **`null`** as the first argument and the response data as the second argument.

The **`fetchData`** function is called with a URL and an anonymous callback function that logs the response data to the console if there is no error, and logs the error message to the console if there is an error.

Callback functions are a powerful tool in JavaScript, as they allow functions to be executed asynchronously and can handle the results of a long-running operation without blocking the main thread of execution.

![截屏2023-04-22 22.32.56.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.32.56.png)

![截屏2023-04-22 22.33.58.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.33.58.png)

![截屏2023-04-22 22.35.18.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.35.18.png)

Callback hell, also known as the pyramid of doom, is a common problem in asynchronous JavaScript programming that occurs when multiple callback functions are nested within each other, making the code difficult to read, maintain, and debug. The problem arises when there are many asynchronous operations that need to be performed in a sequence, with each operation depending on the result of the previous operation.

Here's an example of callback hell:

```jsx
getData(function(data) {
  processData(data, function(result) {
    displayResult(result, function() {
      // More nested callbacks...
    });
  });
});
```

In the above example, the **`getData`** function retrieves data from an API and passes it to the **`processData`** function as a callback. The **`processData`** function processes the data and passes the result to the **`displayResult`** function as a callback. This pattern continues with additional nested callbacks, making the code difficult to read and understand.

To avoid callback hell, there are several techniques that can be used in JavaScript:

1. Modularization - Break the code into smaller, more manageable functions that can be called sequentially.
2. Promises - Use the Promise API to chain multiple asynchronous operations together and handle errors.
3. Async/await - Use the async/await syntax to write asynchronous code in a synchronous style, making it easier to read and maintain.

Here's an example of how to use Promises to avoid callback hell:

```jsx
getData()
  .then(processData)
  .then(displayResult)
  .catch(function(error) {
    console.error(error);
  });
```

In the above example, the **`getData`** function returns a Promise that resolves with the retrieved data. The **`processData`** function takes the data as input and returns a Promise that resolves with the processed result. The **`displayResult`** function takes the result as input and displays it to the user. The **`.then()`** method is used to chain the Promises together, making the code easier to read and understand. The **`.catch()`** method is used to handle any errors that occur during the asynchronous operations.

![截屏2023-04-22 22.35.56.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.35.56.png)

![截屏2023-04-22 22.36.06.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.36.06.png)

**Promises** are a programming construct in JavaScript that allow developers to write asynchronous **异步的** code in a more readable and manageable way. Promises are used to handle the results of asynchronous operations such as making HTTP requests, reading or writing files, or accessing databases.

A Promise is an object that represents a value that may not be available yet, but will be at some point in the future. The Promise can be in one of three states: pending, fulfilled, or rejected. When the Promise is fulfilled, the value is available and can be accessed using the **`.then()`** method. When the Promise is rejected, an error has occurred and can be handled using the **`.catch()`** method.

Here's an example of a Promise in JavaScript:

```jsx

const promise = new Promise(function(resolve, reject) {
  setTimeout(function() {
    resolve('Hello, world!');
  }, 2000);
});

promise.then(function(value) {
  console.log(value);
}).catch(function(error) {
  console.error(error);
});
```

In the above example, a Promise is created using the **`new Promise()`** constructor. The Promise represents a string value that will be available in 2 seconds. The **`setTimeout()`** function is used to simulate an asynchronous operation.

The **`resolve()`** function is used to fulfill the Promise with a value of **`'Hello, world!'`**. The **`reject()`** function can be used to reject the Promise with an error.

The **`.then()`** method is used to handle the fulfilled value of the Promise. In this example, the value is logged to the console.

The **`.catch()`** method is used to handle any errors that occur during the asynchronous operation. In this example, an error message is logged to the console.

Promises are a powerful tool in JavaScript, as they allow developers to write asynchronous code that is more readable, maintainable, and scalable. They are widely used in modern web development and are supported by all major browsers and JavaScript runtimes.

![截屏2023-04-22 22.37.11.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.37.11.png)

![截屏2023-04-22 22.37.26.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.37.26.png)

**Always remember to return** 

![截屏2023-04-22 22.37.38.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.37.38.png)

To return a Promise from a function, you can create a new Promise object and use the **`resolve()`** or **`reject()`** methods to fulfill or reject the Promise.

Here's an example of how to return a Promise from a function:

```jsx
function getData() {
  return new Promise(function(resolve, reject) {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

const result = getData();
result.then(data => console.log(data)).catch(error => console.error(error));
```

In the above example, the **`getData()`** function returns a new Promise object that wraps the **`fetch()`** method. The **`resolve()`** method is used to fulfill the Promise with the retrieved data, while the **`reject()`** method is used to reject the Promise with an error message if there is a problem.

When the **`getData()`** function is called, it returns a Promise object. The **`.then()`** method is used to handle the fulfilled value of the Promise, while the **`.catch()`** method is used to handle any errors that occur during the asynchronous operation.

By returning a Promise from the **`getData()`** function, the Promise can be properly handled and any chained methods are executed as expected.

![截屏2023-04-22 22.38.29.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.38.29.png)

![截屏2023-04-22 22.38.40.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-22_22.38.40.png)

**`forEach`** is a built-in JavaScript method that is used to loop over arrays and execute a function for each element in the array. The **`forEach`** method is similar to a **`for`** loop, but it is more concise and easier to read.

Here's an example of using **`forEach`** to loop over an array:

```jsx
const numbers = [1, 2, 3, 4, 5];
numbers.forEach(function(number) {
  console.log(number);
});
```

In the above example, the **`forEach`** method is used to loop over the **`numbers`** array and log each element to the console.

The main difference between a **`for`** loop and a **`forEach`** loop is in the syntax and readability. A **`for`** loop requires more code to set up and execute, while a **`forEach`** loop is more concise and easier to read. Additionally, a **`for`** loop is often used when you need to loop over an array and perform a specific action, such as sorting or filtering, while a **`forEach`** loop is best used when you simply need to execute a function for each element in the array.

Here's an example of using a **`for`** loop to achieve the same result as the previous **`forEach`** example:

```jsx
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}
```

In the above example, a **`for`** loop is used to loop over the **`numbers`** array and log each element to the console. While this achieves the same result as the previous **`forEach`** example, the **`for`** loop requires more code and is less concise than the **`forEach`** loop.

In summary, **`forEach`** is a built-in JavaScript method that is used to loop over arrays and execute a function for each element in the array. The main difference between a **`for`** loop and a **`forEach`** loop is in the syntax and readability. A **`for`** loop is often used when you need to loop over an array and perform a specific action, while a **`forEach`** loop is best used when you simply need to execute a function for each element in the array.

Some Questions:

![截屏2023-04-24 03.26.29.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-24_03.26.29.png)

![截屏2023-04-24 03.26.37.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-24_03.26.37.png)

![截屏2023-04-24 03.26.51.png](JS-lecture%208eaffd51a0614550bc70c32663a7042a/%25E6%2588%25AA%25E5%25B1%258F2023-04-24_03.26.51.png)